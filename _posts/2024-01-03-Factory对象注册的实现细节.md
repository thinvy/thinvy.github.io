---
title: 【C++设计模式】Factory对象注册的实现细节
author: eren
date: 2024-01-03 00:33:00 +0800
categories: [Blogging]
tags: [programing]
pin: true
math: true
mermaid: true
---

示例为一个后处理的factory注册实现
我们的基本要求是所有后处理统一接口(继承同一个父类)
并且可以在配置文件中进行配置(用户输入一个字符串，根据这个字符串选择执行哪个对象)
并且要优雅(方便继承，新增一个类就在下方写一个宏注册即可，而不是使用繁琐的ifelse写一个加一个case)

```c++
// 后处理基类
class PostProcesser
{
public:
    virtual bool init(void* tensor_addr, std::string params_file, std::string params_position) = 0;

    virtual std::string metadata() = 0;

    virtual void process(DetectResultList & output) = 0;
    virtual void process(SegmentResultList & output) = 0;

};

// 后处理Factory单例
class PostProcesserFactory
{
public:
    template<typename T>
    struct register_t
    {
        register_t(const std::string& key)
        {
            PostProcesserFactory::get().map_.emplace(key, [] { return new T(); });
        }

        template<typename... Args>
        register_t(const std::string& key, Args... args)
        {
            PostProcesserFactory::get().map_.emplace(key, [&] { return new T(args...); });   
        }
    };

    static PostProcesser* produce(const std::string& key)
    {
        if (map_.find(key) == map_.end())
            throw std::invalid_argument("the posp key is not exist!");
        return map_[key]();
    }

    static std::unique_ptr<PostProcesser> produce_unique(const std::string& key)
    {
        return std::unique_ptr<PostProcesser>(produce(key));
    }

    static std::shared_ptr<PostProcesser> produce_shared(const std::string& key)
    {
        return std::shared_ptr<PostProcesser>(produce(key));
    }

private:
    PostProcesserFactory() {};
    PostProcesserFactory(const PostProcesserFactory&) = delete;
    PostProcesserFactory(PostProcesserFactory&&) = delete;

    static PostProcesserFactory& get()
    {
        static PostProcesserFactory instance;
        return instance;
    }

    static std::map<std::string, std::function<PostProcesser*()>> map_;
};

#define REGISTER_POSTPROCESSER_VNAME(T) reg_msg_##T##_
#define REGISTER_POSTPROCESSER(T, key, ...) static PostProcesserFactory::register_t<T> REGISTER_POSTPROCESSER_VNAME(T)(key, ##__VA_ARGS__);

// c++源文件中申明全局变量，编译期间分配内存(不能在头文件中，否则多个引用会出错)
static std::map<std::string, std::function<PostProcesser*()>> map_;

// 后处理功能实现(继承后处理基类, 省略具体实现)
class RmV7CPostProcesser : public PostProcesser
{

public:
    bool init(void* tensor_addr, std::string params_file, std::string params_position) override
    {
        ...
    }

    std::string metadata() override
    {
        ...
    }

    void process(DetectResultList & output) override 
    {
        ...
    }

    void process(SegmentResultList & output) override {...}

    RmV7CPostProcesser() {...}
    ~RmV7CPostProcesser() {...}

private:
    ...
};

// 注册到Factory
REGISTER_POSTPROCESSER(RmV7CPostProcesser, "rm-v7-c-post-processer");

// 调用
...
std::shared_ptr<PostProcesser> posp = PostProcesserFactory::produce_shared("rm-v7-c-post-processer");
...
posp->init(...)
posp->process(...)
```
## 细节解析
### 使用std::map进行字符串和类的关联
std::map的使用不过多赘述

### 宏注册函数的实现
宏的'#...'与'##...##'示例：
```c++
std::string my_str = "hello world";
int my_int = 222;
```
1. C++宏中 x 表示x的内容
```c++
#define LOG(x) (std::cout << "LOG: " << x << std::endl; void(0))
...
LOG(my_str);  // shell: hello world
LOG(my_int);  // shell: 222
```
2. C++宏中 #x 表示字符串 "x"
```c++
#define LOG(x) (std::cout << "LOG: " << #x << std::endl; void(0))
...
LOG(my_str);  // shell: my_str
LOG(my_int);  // shell: my_int
```
3. C++宏中 ##x## 表示将x的内容直接变成c++代码
```c++
void call_func(int func_num)
{
    if(func_num == 1)
        func_1();
    elif(func_num == 2)
        func_2();
    elif(func_num == 3)
        func_3();
}
// 上面这段冗余的代码可以替换成下面这一句话
#define CALL_FUNC(func_num) func_##func_num##()
// 对用户的接口是一样的，并且效率更高，经常用于底层驱动中，缺点是调试中不好跟进这个函数(苦一苦开发者哈哈哈)
call_func(1);
CALL_FUNC(1);
```

### 上述后处理factory的示例解析
```c++
#define REGISTER_POSTPROCESSER_VNAME(T) reg_msg_##T##_
#define REGISTER_POSTPROCESSER(T, key, ...) static PostProcesserFactory::register_t<T> REGISTER_POSTPROCESSER_VNAME(T)(key, ##__VA_ARGS__);
...
REGISTER_POSTPROCESSER(RmV7CPostProcesser, "rm-v7-c-post-processer");
```
写好一个叫做RmV7CPostProcesser的后处理后，调用REGISTER_POSTPROCESSER
```c++
REGISTER_POSTPROCESSER(RmV7CPostProcesser, "rm-v7-c-post-processer");
```
这时执行的行为被编译器进行如下替换:
```c++
#define REGISTER_POSTPROCESSER_VNAME(T) reg_msg_##T##_
#define REGISTER_POSTPROCESSER(T, key, ...) static PostProcesserFactory::register_t<T> REGISTER_POSTPROCESSER_VNAME(T)(key, ##__VA_ARGS__);

REGISTER_POSTPROCESSER(RmV7CPostProcesser, "rm-v7-c-post-processer");
// 翻译成(其中##__VA_ARGS__是用来传递构造函数的入参，但这里不需要，相信可以参考printf之类的实现)
static PostProcesserFactory::register_t<RmV7CPostProcesser> REGISTER_POSTPROCESSER_VNAME(RmV7CPostProcesser)("rm-v7-c-post-processer");
// 继续翻译成
static PostProcesserFactory::register_t<RmV7CPostProcesser> reg_msg_RmV7CPostProcesser("rm-v7-c-post-processer");
// 然后就去执行PostProcesserFactory::register_t的第一个构造函数
// 在这里new了一个RmV7CPostProcesser(没有名字的lambda指针)
// 然后这个对象的地址连同入参的字符串被塞入map_中{"rm-v7-c-post-processer", [] { return new RmV7CPostProcesser();}
// 注意这里register_t里是从Factory的单例里Get的map_，而reg_msg_RmV7CPostProcesser是register_t的一个对象
// 所以这个名字不会对最终填入哪个map产生影响，都是factor的一个map
// 之所以这里用宏的方法对每个注册进来的对象给不同的名字，是因为防止在同一个文件中进行多次注册造成名字冲突
// 就比如在一个文件里，我要注册两个对象
REGISTER_POSTPROCESSER(RmV7CPostProcesser, "rm-v7-c-post-processer");
REGISTER_POSTPROCESSER(RmV5CPostProcesser, "rm-v5-c-post-processer");
// 这里翻译成
static PostProcesserFactory::register_t<RmV7CPostProcesser> reg_msg_RmV7CPostProcesser("rm-v7-c-post-processer");
static PostProcesserFactory::register_t<RmV5CPostProcesser> reg_msg_RmV5CPostProcesser("rm-v5-c-post-processer");
// 然后各自在构造函数中往同一个factor的map_中填入new对象的地址和字符串对
```
```c++
// 之后调用的时候
std::shared_ptr<PostProcesser> posp1 = PostProcesserFactory::produce_shared("rm-v7-c-post-processer");
std::shared_ptr<PostProcesser> posp2 = PostProcesserFactory::produce_shared("rm-v5-c-post-processer");
// 意思很简单就是在PostProcesserFactory::map_这个全局map中找输入字符串对应的对象地址(这里找到后打包成了智能指针)
// 回想一下，对象在注册的时候就被new构造了，因为是在全局内存上，这一步在程序一开始的时候进行，并且不保证构造顺序
// 因此我在实际使用的时候并没有使用最方便的方法，即写完类就在下面写个注册，而是丢到一个统一的函数中进行注册，这样可以可以避免很多问题，就是可能不太优雅
// 至于PostProcesserFactory::produce_shared的过程，这里不执行构造，因此基本不耗时
```
以上就是全部的细节解析

这时，聪明的小伙伴会想到，下面这种写法是同样的原理呀
```c++
// Factory源文件
static std::map<std::string, std::function<PostProcesser*()>> op_map;

template<typename T>
void register_postprocesser(std::string key)
{
    op_map.emplace(key, [] { return new T(); });
}

std::shared_ptr<PostProcesser> get_shared_postprocesser_op(std::string key)
{
    if (map_.find(key) == map_.end())
        throw std::invalid_argument("the posp key is not exist!");
    auto p_op = op_map[key]();
    return std::shared_ptr<PostProcesser>(p_op);
}

// Factory头文件
template<typename T> void register_postprocesser(std::string key);
#define REGISTER_POSTPROCESSER(T, key) register_postprocesser<##T##>(key)

std::shared_ptr<PostProcesser> get_shared_postprocesser_op(std::string key);

// 注册
REGISTER_POSTPROCESSER(RmV7CPostProcesser, "rm-v7-c-post-processer");

// 调用
auto posp = get_shared_postprocesser_op("rm-v7-c-post-processer");
posp->init(...);
posp->process(...);
...
```
这样写不是更简单更容易理解

哈哈哈你说得对，但是这样不够
![Desktop View](https://raw.githubusercontent.com/thinvy/thinvy.github.io/main/_img/common/my_photo/lqy.jpg){: width="972" height="589" }

**实际工作中建议还是按照下面这个简单方法实现，原理和单例方法一样，代码在维持高效的前提下要尽量易于理解并减小代码体积**